#' @title Parsing raw WhatsApp Chat Textfiles according to Android text structure
#'
#' @description Creates a data frame from an exported WhatsApp textfile containing one row per message
#' and a column for DateTime when the message was sent, name of the sender and body of the message.
#' @param UnparsedChat the name of the exported Whatsapp textfile to be parsed as a character string.
#' @param nl character string defining character for newline indicators. Default is a Unicode newline.
#' @param mediaindicator character string for detecting media and file attachments.
#' @param mediaomitted character string inserted by WhatsApp instead of file names when not exporting media.
#' @param sentlocation Regex for detecting autogenerated messages for locations shared via chat.
#' @param livelocation Regex for detecting autogenerated messages for live locations shared via chat.
#' @param datetimeindicator Regex for detecting the DateTime indicator at the beginning of each message.
#' @param nlreplace replacement string for a newline character in parsed message. Default is " START_NEWLINE ".
#' @param mediareplace replacement string for omitted media files. Default is " media_omitted ".
#' @export
#' @importFrom qdapRegex rm_default
#' @importFrom stringi stri_split_fixed stri_split_regex stri_split stri_extract_all
#' @importFrom lubridate parse_date_time
#' @return A data frame containing the timestamp, name of the sender and message body
#' @examples
#' ParsedChat <- parse_android("29.01.18, 23:33 - Alice: Hi?\n 29.01.18, 23:45 - Bob: Hi\n")
parse_android <- function(UnparsedChat,
                          nl = "\n",
                          mediaomitted = "<media omitted>",
                          mediaindicator = "(file attached)",
                          sentlocation = paste0(
                            "Location: (?=https:\\/\\/maps\\.google\\.com\\/",
                            "\\?q=\\d\\d.\\d{6}\\,\\d\\.\\d{6})"
                          ),
                          livelocation = "^live location shared$",
                          datetimeindicator = paste("(?!^)(?=((\\d{2}\\.\\d{2}\\.\\d{2})|(\\d{1,2}",
                            "\\/\\d{1,2}\\/\\d{2})),\\s\\d{2}\\:\\d{2}((\\s\\-)|(\\s(?i:(am|pm))\\s\\-)))",
                            sep = ""
                          ),
                          nlreplace = " start_newline ",
                          mediareplace = " media_omitted ") {
  # Replaceing string for omitted media
  chat1 <- gsub(
    pattern = mediaomitted,
    UnparsedChat,
    replacement = mediareplace,
    perl = TRUE
  )

  # TODO:
  # FIRST DIGIT OF DATE IS BEING CUT OFF DUE TO PARTIAL MATCHING
  chat2 <- unlist(stri_split(chat1, regex = datetimeindicator))

  # Quick fix:
  # This pastes together the cut-off first digits from the datetime indicators but leaves the incomplete dates
  # TODO: Fix this later and replace with a better regex
  chat3 <- chat2
  for (i in 1:length(chat2)) {
    if (nchar(chat2[i]) == 1) {
      chat3[i] <- paste(chat2[i], chat2[i + 1], sep = "")
    } else {
      chat3[i] <- chat2[i]
    }
  }

  # deleting the additional lines with the incomplete dates
  chat3[which(nchar(chat2) == 1) + 1] <- NA
  chat4 <- chat3[!is.na(chat3)]

  # deleting trailing Linebreakes (simply deletes the last character)
  chat5 <- substr(chat4, 1, nchar(as.character(chat4)) - 1)

  # Replacing Linebreaks within messages
  chat6 <- rm_default(chat5,
    pattern = nl,
    replacement = nlreplace
  )

  ### We cut the message to form vectors for datetime, sender and the actual message

  # Splitting
  DateSplit <- stri_split_fixed(
    str = chat6,
    pattern = " - ",
    n = 2
  )

  SenderSplit <- stri_split_fixed(
    str = sapply(DateSplit, "[", 2),
    pattern = ": ",
    n = 2
  )

  # Extract DateTime and encode correctly
  DateTime <- sapply(DateSplit, function(x) {
    x[1]
  })

  # Defining Time orders for lubridate::parse_date_time() function
  timestrings <- c(
    "dmy, HMS",
    "dmy, HM",
    "dmy, IMp",
    "dmy, IMSp",
    "mdy, HMS",
    "mdy, HM",
    "mdy, IMp",
    "mdy, IMSp"
  )

  DateTime <- parse_date_time(DateTime,
    orders = timestrings,
    select_formats = TRUE
  )

  # Extract Sender and encode correctly
  Sender <- sapply(SenderSplit, "[", 1)

  # Extract Message
  Message <- sapply(SenderSplit, "[", 2)

  ###### Media

  # removing indicator string for attached files
  Media <- stri_split_regex(str = Message, pattern = mediaindicator, n = 2)
  Media[which(sapply(Media, length) == 1)] <- NA # TODO: This will assign everything to be NA if there is no NA list element in the Media string (fix later)
  Media <- sapply(Media, "[", 1)

  # Deleting trailing characters
  Media[!is.na(Media)] <- substr(Media[!is.na(Media)], 1, nchar(Media[!is.na(Media)]) - 2)

  # extract location to column
  Location <- stri_extract_all(Message, regex = paste(c(livelocation, sentlocation), collapse = "|"))
  Location[sapply(Location, length) == 0] <- NA
  Location <- unlist(Location)

  # binding the columns together
  Result <- cbind.data.frame(DateTime,
    Sender,
    Message,
    Media,
    Location,
    stringsAsFactors = FALSE
  )

  # returning parsed Result
  return(Result)
}
